# 1．考虑下面的类声明:class RQ1

```cpp
class RQ1
{
private:
	char * st; // points to C-style string
public:
	RQ1 () { st = new char [1] ; strcpy(st, "" ) ;}
    RQ1(const char * s){st = new char [strlen (s) + 1] ; strcpy(st,s); }
    RQ1 (const RQ1 & rq){st = new char [strlen (rq.st) + 1]; strcpy(st,rq.st);}
    ~RQ1() { delete [] st} ;
	RQ & operator= (const RQ & ra) ;
    // more stuff
};
```

将它转换为使用string 对象的声明。哪些方法不再需要显式定义?

转换为使用 `std::string` 对象的声明，可以省略手动管理内存的部分，因为 `std::string` 负责处理字符串的内存管理。下面是转换后的声明：



# 2．在易于使用方面，指出string 对象至少两个优于C-风格字符串的地方。

`std::string` 对象相较于 C-风格字符串在易于使用方面至少有两个优点：

1. **动态内存管理：** `std::string` 对象自动管理字符串的内存，无需手动分配和释放内存。这减轻了程序员的负担，避免了内存泄漏和越界访问等问题。
2. **自动长度管理：** `std::string` 对象包含了字符串的长度信息，因此不需要额外的变量来记录字符串的长度。这使得操作字符串更加方便，不容易出现因长度不匹配而引发的错误。

综合而言，使用 `std::string` 对象可以使字符串处理更加安全、方便和易于理解，避免了 C-风格字符串的许多潜在问题。



# 3．编写一个函数，用string对象作为参数，将string对象转换为全部大写。

```cpp
std::string toUpperCase(const std::string& str) {
    std::string result = str;
    for (char& c : result) {
        c = std::toupper(c);
    }
    return result;
}
```



# 4．从概念上或语法上说，下面哪个不是正确使用auto_ptr的方法（假设已经包含了所需的头文件)?

```cpp
auto_ptr<int> pia(new int [20]);
auto_ptr<string> (new string);
int rigue = 7;auto_ptr<int>pr (&rigue);
auto_ptr dbl (new double);
```

1. `auto_ptr<int> pia(new int [20]);`  这是一个数组，`auto_ptr` 不适用于管理数组，因为它使用 `delete` 而不是 `delete[]`。在现代 C++ 中，推荐使用 `std::unique_ptr` 和 `std::vector` 来管理动态数组。
2. `auto_ptr<string> (new string);` - 这个语法是不正确的。应该使用变量名来初始化 `auto_ptr`，比如 `auto_ptr<string> ptr(new string);`
3. `auto_ptr<int> pr(&rigue);` - 这样使用 `auto_ptr` 是不安全的，因为 `auto_ptr` 假定它独占内存的所有权。在这里，`&rigue` 是一个指向栈上对象的指针，不应该由 `auto_ptr` 接管。
4. `auto_ptr dbl(new double);` - 这个语法是不正确的。应该使用变量名来初始化 `auto_ptr`，比如 `auto_ptr<double> dbl(new double);`

总的来说，`auto_ptr` 存在概念上的问题，而现代 C++ 推荐使用更安全的智能指针，如 `std::unique_ptr` 或 `std::shared_ptr`。



# 5．如果可以生成一个存储高尔夫球棍（而不是数字）的栈，为何它（从概念上说)是一个坏的高尔夫袋子?

栈（Stack）是一种后进先出（LIFO）的数据结构，即最后进入栈的元素是第一个被取出的。在高尔夫中，球棍的使用通常是按照先后顺序，而不是后进先出的顺序。球棍的选择和使用通常与栈的后进先出特性不符。

一个好的高尔夫袋子应该能够存储和组织高尔夫球杆，以便能够轻松地选择并取出需要的球棍。这通常需要一种能够随机访问元素的数据结构，比如数组或者支持快速查找的容器。

因此，使用栈来表示高尔夫球棍的袋子是不合适的，因为栈的特性与高尔夫球棍的组织方式不一致。



# 6．为什么说对于逐洞记录高尔夫成绩来说，set容器是糟糕的选择?

`std::set` 是一种关联容器，它维护有序的、唯一的元素集合。对于逐洞记录高尔夫成绩的情况，`std::set` 可能不是一个理想的选择，原因如下：

1. **唯一性要求：** `std::set` 要求元素唯一，而高尔夫成绩记录可能包含相同的分数，尤其是在同一洞上。这就限制了使用 `std::set` 来存储成绩，因为它不允许重复的元素。
2. **无法直接修改元素：** `std::set` 中的元素是只读的，一旦插入就不能修改。在高尔夫中，玩家可能需要更新他们在某个洞的成绩，但使用 `std::set` 需要删除旧的记录并插入新的记录。
3. **按照顺序插入：** `std::set` 会按照元素的比较函数插入，这可能与逐洞记录成绩的顺序不一致。高尔夫成绩通常是按照洞的顺序记录的，而不是按照分数的顺序。

对于逐洞记录高尔夫成绩，更适合的数据结构可能是 `std::vector` 或 `std::array`，因为它们允许按照顺序存储元素，并且允许直接访问和修改元素。



# 7．既然指针是一个迭代器，为什么STL 设计人员没有简单地使用指针来代替迭代器呢?

1. **泛型编程：** 迭代器提供了一种比指针更为抽象的方式来表示数据的位置，使得算法和数据结构能够更通用地适应各种数据类型。这是泛型编程的核心理念，使得STL的组件能够与不同类型的容器协同工作。
2. **容器独立性：** 迭代器提供了一种容器独立的方式来访问元素。指针通常与特定类型的容器绑定，而迭代器允许在不同类型的容器中使用相同的算法，而无需关心底层容器的实现。
3. **更多功能：** 迭代器可以提供比指针更多的功能。例如，迭代器可以支持逆向遍历、随机访问、迭代器分类等特性，而这些特性在通用算法中非常有用。指针仅提供了一些基本的操作，缺乏这些高级功能。
4. **安全性：** 迭代器可以提供更多的安全性。与指针相比，迭代器通常提供了更多的错误检测和保护机制，防止在容器范围之外进行访问。这有助于减少潜在的错误和提高程序的健壮性。
5. **抽象层次：** 迭代器提供了一个更高层次的抽象，允许开发人员专注于算法的设计而不用过多考虑底层数据结构的实现细节。这有助于提高代码的可维护性和可读性。

总体而言，迭代器相对于指针更适合STL的设计目标，即实现泛型、容器独立、功能丰富和安全性高的算法和数据结构。通过使用迭代器，STL实现了一套强大而通用的标准库，使得C++程序员能够更方便地处理各种数据结构。



# 8．为什么STL 设计人员仅定义了迭代器基类，而使用继承来派生其他迭代器类型的类，并根据这些迭代器类来表示算法?

STL 设计人员选择定义迭代器基类并使用继承来派生其他迭代器类型的类，以及根据这些迭代器类来表示算法，有几个原因：

1. **多态性：** 通过定义迭代器基类，可以实现多态性，使得不同类型的迭代器可以被用作相同的基类指针，从而实现更灵活的算法设计。这使得算法能够适应不同类型的容器，而无需修改算法本身。
2. **通用性：** 这种设计允许算法能够适用于不同种类的迭代器，包括输入迭代器、输出迭代器、前向迭代器、双向迭代器和随机访问迭代器。这些迭代器类别提供了不同级别的功能，使得算法能够充分利用底层容器的特性。
3. **代码复用：** STL 中的算法和迭代器之间的解耦允许更好的代码复用。相同的算法可以在不同类型的容器上使用，而无需重新实现。这种设计促进了模块化和可维护性。
4. **灵活性：** 使用迭代器基类和继承的设计使得用户可以定义和使用自定义的容器和迭代器，而这些自定义容器和迭代器可以与STL的标准算法协同工作。这提供了更大的灵活性和扩展性。
5. **简化接口：** 将不同类型的迭代器归类到迭代器基类下，简化了算法的接口。算法可以通过操作迭代器接口，而无需关心底层容器的具体类型。

总体而言，使用迭代器基类和继承的设计使STL更具通用性、可扩展性和灵活性，同时促进了代码的复用和模块化。这种设计风格也是面向对象编程中的一种经典设计模式。



# 9.给出vector对象比常规数组方便的3个例子。

1. **动态大小：** Vector 可以动态调整其大小，而常规数组的大小是固定的。在运行时，你可以通过添加或删除元素来改变 vector 的大小，而不需要手动管理内存。这提供了更大的灵活性，使得容器适应不同数量的元素。

```cpp
// 使用 vector
std::vector<int> myVector;
myVector.push_back(1);
myVector.push_back(2);
myVector.push_back(3);

// 不需要指定大小，可以根据需要动态添加元素
```

2. **自动内存管理：** Vector 对象会自动处理内存管理。它使用动态内存分配，避免了在常规数组中可能遇到的内存溢出或内存泄漏问题。当 vector 的大小超过其当前容量时，它会自动重新分配更大的内存。

```cpp
// 不需要手动管理内存
std::vector<int> myVector;
myVector.push_back(1);
myVector.push_back(2);
// ...
```

3. **方便的成员函数和算法：** Vector 类提供了丰富的成员函数和算法，使得对元素进行操作更加方便。例如，你可以使用 `push_back` 添加元素，使用 `pop_back` 删除元素，使用 `size` 获取当前元素数量等。此外，你还可以使用算法库中的函数进行排序、查找等操作。

```cpp
// 使用 vector 的成员函数和算法
std::vector<int> myVector = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5};
std::sort(myVector.begin(), myVector.end());  // 排序

int sum = std::accumulate(myVector.begin(), myVector.end(), 0);  // 计算总和
```



# 10．如果程序清单16.9是使用list(而不是vector)实现的，则该程序的哪些部分将是非法的?非法部分能够轻松修复吗?如果可以，如何修复呢?



1. **迭代器失效：** 使用 `list` 的一个主要区别是，在插入或删除元素时，`list` 的迭代器不会失效，而 `vector` 可能会失效。因此，不需要像在 `vector` 中那样担心迭代器失效的问题。
2. **改变循环方式：** 由于 `list` 不支持随机访问，不能像使用 `vector` 那样使用索引来访问元素。因此，在使用 `list` 时，需要使用迭代器进行循环。



# 11．假设有程序清单16.15所示的函数符TooBig.

下面的代码有何功能? 赋给bo的是什么值?bool bo = TooBig<int>(10)(15);

在程序清单16.15中，`TooBig` 是一个函数模板，它接受一个参数 `limit`，并返回一个函数对象。这个函数对象接受一个参数 `v`，并返回一个 `bool` 值，表示 `v` 是否大于 `limit`。

对于给定的代码：

```cpp
bool bo = TooBig<int>(10)(15);
```

这行代码的功能是创建一个 `TooBig` 函数对象，使用 `int` 作为模板参数，并将 `limit` 设置为 `10`。然后，这个函数对象被调用，参数为 `15`。因此，`bo` 将获得 `TooBig<int>(10)(15)` 的返回值。

在这个特定的示例中，返回值将是 `true`，因为 `15` 大于 `10`。所以，`bo` 将被赋值为 `true`。